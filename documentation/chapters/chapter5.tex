% 4. Criptografía post-cuántica basada en códigos. 
% Aquí depende de si vas a matricularte en la asignatura de Criptografía (la imparte Javier Lobillo). 
% Allí te explicarán los sistemas asimétricos. Si no te matriculas, lo puedes encontrar en el libro Introduction to Cryptography (capítulos 1,2,3).
% No te hace falta todo lo que hay en esos capítulos, pero, bueno, es interesante para una matemática/informática el conocer este tipo de cosas.
% Para la parte post-cuántica, tenemos el archivo 9783540887010-c1.pdf y el libro Post-QuantumCryptography 
% (capítulos Introduction to post-quantum cryptography y Code-based cryptography, también Quantum computing, si te apetece). 
% Para el criptosistema de McEliece (que es que implementaremos) está el archivo sander-report-s15.pdf, 
% donde se explica este y el criptosistema de Niederreter, que es equivalente en seguridad.

% buscar la referencia original del 78 de McEliece que ahi viene mejor explicado

\chapter{Criptografía post-cuántica basada en códigos}

% TODO: introducción


El principal objetivo de la criptografía es proporcionar confidencialidad mediante métodos de cifrado. Cuando queremos enviar un mensaje a un destinatario, el canal de comunicación puede ser inseguro y otras personas podrían leerlo o incluso modificarlo de tal forma que el destinatario no se diera cuenta. Para prevenir estos ataques nos será de utilidad la criptografía.


\section{Introducción}

En general, los métodos de cifrado consisten en encriptar el mensaje, \emph{texto llano}, antes de ser transmitido, de esta forma obtenemos un \emph{texto cifrado}. Este texto cifrado se transmite al destinatario, quien lo \emph{desencripta} mediante una \emph{clave de descifrado}, la cual solo conocen el receptor y el emisor y previamente la intercambiaron.

Para encriptar y desencriptar existen \emph{algoritmos de cifrado} y \emph{de descifrado}, respectivamente, y cada uno usará una clave secreta. Si esta clave es la misma en ambos algoritmos, diremos que los métodos de encriptación son \emph{simétricos}. Algunos ejemplos importantes de estos métodos son DES (\emph{Data Encryption Standard}) y AES (\emph{Advanced Encryption Standard}).

En 1976, Diffie y Hellman introdujeron un concepto revolucionario, la \emph{criptografía de Clave Pública}, que permitió dar una solución al antiguo problema del intercambio de claves e indicar el camino a la firma digital. Los métodos de cifrado de \emph{clave pública} son \emph{asimétricos}. Cada receptor tiene una clave personal $k = (pk, sk)$, que consiste en dos partes: $pk$ es la clave de cifrado y es pública, y $sk$ es la clave de descifrado, que es privada. De esta forma, si queremos enviar un mensaje, lo encriptaremos mediante la clave pública $pk$ del receptor. Así, el receptor poddrá descifrar el texto cifrado usando su clave privada $sk$, que solo la conoce él. Al ser la clave pública, cualquiera puede encriptar un mensaje usándola, sin embargo descifrarlo sin saber la clave privada será casi imposible.

\section{Objetivos de la criptografía}

Además de proporcionar confidencialidad, la criptografía proporciona soluciones para otros problemas:

\begin{enumerate}
    \item \emph{Integridad de datos}. El receptor de un mensaje debería ser capaz de determinar que el mensaje no ha sido modificado durante la transmisión.
    \item \emph{Autenticación}. El receptor de un mensaje debería ser capaz de verificar su origen.
    \item \emph{No repudiabilidad}. El emisor de un mensaje debería ser incapaz de negar posteriormente que envió el mensaje.
\end{enumerate}

Para garantizar la integridad de los datos, hay métodos simétricos y de clave pública. El mensaje $m$ es aumentado por un \emph{código de autenticación de mensaje} (MAC). Este código es generado por un algoritmo que depende de la clave secreta. Así, el mensaje aumentado $(m, MAC(k,m))$ está protegido contra modificaciones. El receptor ahora puede comprobar la integridad del mensaje $(m, \bar{m})$ verificando que $MAC(k, m) = \bar{m}$. Más adelante veremos que la autenticación de códigos se puede implementar con funciones hash con clave.

Las firmas digitales requieren métodos de clave pública y proporcionan autenticación y no repudiablidad. Cualquier persona puede verificar si una firma digital es válida con la clave pública del firmante. Esto es, si firmamos con nuestra clave privada $k$, obtenemos la firma $Sign(sk, m)$. El receptor recibe la firma $s$ del mensaje $m$ y comprueba con el algoritmo de verificación \emph{Verify} que se cumple que $Verify(pk, s, m) = ok$, siendo $pk$ la clave pública del emisor.

\section{Criptografía de Clave Pública}

A diferencia de la criptografía simétrica, en la criptografía de clave pública los participantes en la comunicación no comparten una clave secreta. Cada uno tiene un par de claves: la \emph{clave secreta} $sk$ conocida solo por él y una \emph{clave pública} conocida por todos.

Supongamos que Bob tiene un par de claves $(pk, sk)$ y Alice quiere encriptar un mensaje $m$ para Bob. Alice, como cualquier otra persona, conoce la clave pública $pk$ de Bob. Alice usa una función de encriptación $E$ con la clave pública $pk$ de Bob para obtener el texto cifrado $c = E(pk, m)$. Denotamos la encriptación con una llave fija $pk$ por $E_{pk}$, es decir, $E_{pk} := E(pk, m)$. Esto solo puede ser seguro si es prácticamente inviable calcular $m$ de $c = E_{pk}(m)$. Sin embargo, Bob sí es capaz de calcular el mensaje $m$, ya que puede usar su clave secreta. La función de encriptación $E_{pk}$ debe tener la propiedad de que su pre-imagen $m$ del texto cifrado $c = E_{pk}(m)$ sea fácil de calcular usando la clave secreta $sk$ de Bob, quien es el único que puede descifrar el mensaje encriptado.

En la criptografía de clave pública, necesitamos unas funciones $\left( E_{pk} \right)_{pk \in PK}$ tales que cada función $E_{pk}$ se pueda cacular con un algoritmo eficiente. Sin embargo, su pre-imagen debería ser prácticamente inviable de calcular. Estas familias $\left( E_{pk} \right)_{pk \in PK}$ se denominan \emph{funciones de una sola dirección}. En cada función $E_{pk}$ de la familia, tiene que haber una información secreta $sk$ para que el algoritmo sea eficiente y calcule la inversa de $E_{pk}$. Las funciones con esa propiedad se denominan \emph{funciones con trampilla}.

En 1976, Diffie y Hellman presentaron la idea de la criptografía de clave pública, es decir, introdujeron métodos de clave pública para el acuerdo de clave y, además, describieron cómo las firmas digitales funcionarían. El primer criptosistema de clave pública que podía servir como un mecanismo de acuerdo de clave y como una firma digital fue el criptosistema RSA, que actualmente es el más conocido y usado. Este criptosistema lleva el nombre de sus inventores: Rivest, Shamir y Adleman. El criptosistema RSA se basa en la dificultad de factorizar grandes números, lo que le permite construir funciones de una sola dirección con una trampilla. Otras funciones de una sola dirección se basan en la dificultad de extraer logaritmos discretos. Estos dos problemas de la teoría de números son los cimientos de los criptosistemas de clave pública más usados actualmente.

Cada participante en un criptosistema de clave pública tiene una clave $k = (pk, sk)$, que consiste enu na clave pública ($pk$) y una clave privada o secreta ($sk$). Para garantizar la seguridad del criptosistema, debería ser inviable obtener la clave privada $sk$ a partir de la clave pública $pk$. Un algoritmo eficiente debería ser el encargado de elegir aleatoriamente ambas claves en un gran espacio de parámetros. Así, cualquiera puede usar $pk$ para encriptar mensajes, pero solo quien posea $sk$ podrá desencriptarlos.

En cuanto a las firmas digitales, supongamos que tenemos una familia de funciones con trampilla $\left( E_{pk} \right)_{pk \in PK}$ donde cada función $E_{pk}$ es biyectiva. Sea $pk$ la clave pública de Alice, quien es la única de calcular la inversa $E_{pk}^{-1}$ de $E_{pk}$ pues para ello se necesita la clave privada $sk$ de Alice. De esta forma, si Alice quiere firmar un mensaje $m$, tiene que calcular $E_{pk}^{-1}(m)$, que será el valor de la firma $s$ de $m$. Todo el mundo puede verificar la firma de Alice $s$ pues cualquiera puede usar su clave pública $pk$ y calcular $E_{pk}(s)$. Si $E_{pk} (s) = m$, entonces podemos asegurarnos de que Alice realmente firmó $m$ porque es la única que es capaz de calcular $E_{pk}^{-1}(m)$.

Una importante aplicación de los criptosistemas de clave pública es que permiten intercambiar claves en sistemas de clave secreta. Si Alice conoce la clave pública de Bob, ella puede generar una clave de sesión, cifrarla con la clave pública de Bob y enviársela.  

Algunos sistemas conocidos de clave pública son:

\begin{itemize}
    \item \emph{RSA}: está basado en el problema de factorización de enteros.
    \item \emph{ElGamal}: está basado en el problema del logaritmo discreto.
    \item \emph{McEliece}: está basado en la teoría de los códigos Goppa.
    \item \emph{Curvas Elípticas}: son una generalización del sistema ElGamal y se basan en el problema de calcular logaritmos discretos en curvas elípticas.
\end{itemize}

\section{RSA}

El criptosistema RSA consiste en multiplicar dos números primos muy grandes y publicar su producto $n$. Una parte de la clave pública la conformará $n$, mientras que los factores de $n$ se mantienen en secreto y se usarán como clave privada. La idea básica es que los factores de $n$ no puedan recuperarse de $n$. Por lo que la seguridad de RSA radica en la dificultad del problema de factorización de enteros.

\subsection{Generación de claves}

Cada usuario del criptosistema RSA posee una clave pública y otra privada. Para generar este par de claves, se siguen los siguientes tres pasos:

\begin{enumerate}
    \item Se eligen aleatoriamente dos grandes números primos distintos $p$ y $q$ y se calcula su producto $n = p \cdot q$.
    \item Se elige un entero $e$ tal que $1 < e < \phi(n)$ y sea primo con $\phi(n)$. La clave pública será $(n, e)$.
    \item Se calcula $d$ que verifique $ed \equiv 1 \pmod{\phi(n)}$. La clave privada será $(n, d)$.
\end{enumerate}

Los números $n$, $e$ y $d$ se denominan \emph{módulo}, \emph{exponente de cifrado} y \emph{exponente de descifrado}, respectivamente. El exponente de descifrado $d$ se puede obtener con el algoritmo extendido de Euclides. Con este exponente es posible descifrar un texto cifrado y generar una firma digital.

\subsection{Cifrado y descifrado}

Supongamos que queremos cifrar un mensaje para Bob. Para ello, usaremos la clave pública $(n, e)$ de Bob. Los mensajes que podemos encriptar $m \in \{ 0, ..., n-1 \}$ se pueden considerar elementos de $\mathbb{Z}_n$.

Para cifrar un texto plano $m \in \mathbb{Z}_n$, podemos usar la función RSA

$$RSA_{n, e} : \mathbb{Z}_n \longrightarrow \mathbb{Z}_n, \; m \longmapsto m^e,$$

es decir, el texto cifrado $c$ es $m^e$ módulo $n$.

Para que Bob descifre el texto cifrado $c$, puede usar la función RSA

$$RSA_{n, d} : \mathbb{Z}_n \longrightarrow \mathbb{Z}_n, \; c \longmapsto c^d,$$

donde $(n, d)$ es su clave secreta. De esta forma, Bob puede recuperar el texto plano, es decir, $m = c^d$ módulo $n$, pues las funciones de cifrado y descifrado $RSA_{n, e}$ y $RSA_{n, d}$ son inversas entre sí.

Con este procedimiento de cifrado, podemos cifrar secuencias de bit hasta $k := \lfloor \log_2{n} \rfloor$ bits. Si los mensajes son más largos, podemos dividirlos en bloques de longitud $k$ y cifrar cada uno por separado.

\section{Criptografía post-cuántica}


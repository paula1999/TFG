% 2. Códigos de Goppa.
% Esto lo puedes encontrar en el capítulo 13 de Huffman y Pless. 
% La decodificación  de estos códigos, es similar a la de los códigos BCH (capítulo 5) utilizando el algoritmo de Sugiyama. 
% El artículo donde se definen y se decodifican es el de Goppa.pdf. 
% Además, ahi se explica de forma elemental, sin utilizar geometría algebraica.

\chapter{Códigos de Goppa}

% TODO: introduccion
\textcolor{red}{Hay que completar esta introducción}

Goppa describió una nueva clase de códigos de corrección de errores lineales no cíclicos. Lo más importante es que algunos de estos códigos excedían el límite asintótico de Gilbert-Varshamov, una hazaña que muchos teóricos códigos pensaban que nunca podría lograrse. En este capítulo vamos a hablar sobre los códigos de Goppa y sus propiedades más importantes.


El desarrollo de este capítulo se ha basado en \cite{Huffman_Pless_2010} y \cite{Goppa_codes_1973}.

\section{Algunos códigos clásicos}

Antes de estudiar los códigos de Goppa, introduciremos algunos códigos clásicos para motivar el objetivo de este capítulo.

\subsection{Códigos BCH}

% TODO: definición de código cíclico
\textcolor{red}{TODO: definir los códigos cíclicos}

Los códigos BCH son una de las muchas familias importantes de los códigos cíclicos. Consideramos un código cíclico $\mathcal{C}$ de longitud $n$ sobre $\mathbb{F}_q$ y sea $\delta$ un entero tal que $2 \leq \delta \leq n$. Diremos que $\mathcal{C}$ es un \emph{código BCH} sobre $\mathbb{F}_q$ de longitud $n$ y distancia prevista $\delta$ es un código cíclico con el conjunto

\begin{equation}
    \label{def:conjunto_BCH}
    T = C_b \cup \cdots \cup C_{b + \delta - 2}
\end{equation}

donde $C_i$ es la clase q-ciclotómica módulo $n$ que contiene a $i$. Este código tiene distancia mínima al menos $\delta$ y su dimensión es $n - \vert T \vert$.


Variando el valor de $b$ podemos obtener una variedad de códigos con diferentes distancias mínimas y dimensiones. Cuando $b = 1$, $\mathcal{C}$ es un código BCH de \emph{sentido estricto}. Como con cualquier código cíclico, si $n = q^t - 1$, entonces $\mathcal{C}$ es un código BCH \emph{primitivo}.

\subsection{Códigos Reed-Solomon}

En esta sección definiremos los códigos Reed-Solomon, que abreviaremos como códigos RS, como una subfamilia de los códigos BCH.

\begin{definition}
    Un código RS $\mathcal{C}$ sobre $\mathbb{F}_q$ es un código BCH de longitud $n = q - 1$.
\end{definition}

El siguiente resultado nos muestra las propiedades de estos códigos.

\begin{theorem}
    Sea $\mathcal{C}$ un código RS sobre $\mathbb{F}_q$ de longitud $n = q - 1$ y distancia prevista $\delta$. Entonces:

    \begin{enumerate}
        \item $\mathcal{C}$ tiene conjunto $T = \{ b, ..., b + \delta - 2 \}$ para algún entero $b$.
        \item $\mathcal{C}$ tiene distancia mínima $d = \delta$ y dimensión $k = n - d + 1$.
    \end{enumerate}
\end{theorem}

\begin{proof}
    % TODO: demostracion
    \begin{enumerate}
        \item \textcolor{red}{Hay que completar esta demostración (cuando sepa qué son las clases q-ciclotómicas jeje).}
        \item Como $\mathcal{C}$ es un código BCH, entonces su distancia mínima es $d = \delta$ y su dimensión es $n - \vert T \vert = n - (\delta - 1) = n - \delta + 1 = n - d + 1$.
    \end{enumerate}
\end{proof}


\begin{comment}
    % TODO: esto sirve?
A continuación, introduciremos la definición de los códigos Reed-Solomon generalizados.

Para $k \geq 0$, $\mathcal{P}_k$ denota el conjunto de polinomios de grado menor que $k$, incluyendo el polinomio nulo, en $\mathbb{F}_q[x]$. Sea $n$ un número entero tal que $1 \leq n \leq q$, $\gamma = (\gamma _0,..., \gamma _{n-1})$ una n-tupla de elementos distintos de $\mathbb{F}_q$, y $\textbf{v} = (v_0,...,v_{n-1})$ una n-tupla de elementos no nulos de $\mathbb{F}_q$. Sea $k$ un número entero tal que $1 \leq k \leq n$. Entonces los códigos

$$GRS_k (\gamma, \textbf{v}) = \left\{ \left( v_0 f(\gamma_0), ..., v_{n-1}f(\gamma_{n-1}) \right) : f \in \mathcal{P}_k \right\}$$

son los códigos Reed-Solomon generalizados (códigos GRS).
\end{comment}

\section{Códigos clásicos de Goppa}

Los códigos clásicos de Goppa se introdujeron por V. D. Goppa en 1970. Estos códigos son generalizaciones de códigos BCH y subcódigos de subcuerpos de ciertos códigos GRS.

Para motivar la definición de los códigos de Goppa, introduciremos una construcción de los códigos BCH de longitud $n$ sobre $\mathbb{F}_q$. Sea $t = ord_q(n)$ y sea $\beta$ la raíz enésima primitiva de la unidad en $\mathbb{F}_{q^t}$. Elegimos $\delta > 1$ y sea $\mathcal{C}$ el código BCH de longitud $n$ y distancia $\delta$. Entonces $c(x) = c_0 + c_1x + \cdots + c_{n-1}x^{n-1} \in \mathbb{F}_q [x] / (x^n - 1)$ está en $\mathcal{C}$ si y solo si $c(\beta^j) = 0$ para $1 \leq j \leq \delta - 1$. Tenemos que 

$$(x^n - 1) \sum_{i=0}^{n-1} \frac{c_i}{x - \beta ^{-i}} = \sum_{i=0}^{n-1} c_i \sum_{l=0}^{n-1} x^l \left( \beta ^{-i} \right) ^{n-1-l} = \sum_{l=0}^{n-1} x^l \sum_{i=0}^{n-1} c_i \left( \beta^{l+1} \right) ^i.$$

Como $c(\beta^{l+1}) = 0$ para $0 \leq l \leq \delta - 2$, el lado derecho de la ecuación es un polinomio cuyo término de menor grado tiene grado al menos $\delta - 1$. Por lo tanto, el lado derecho se puede escribir como $x^{\delta - 1} p(x)$, donde $p(x)$ es un polinomio en $\mathbb{F}_{q^t}[x]$. Así, podemos decir que $c(x) \in \mathbb{F}_q[x] / (x^n - 1)$ está en $\mathcal{C}$ si y solo si 

$$\sum_{i=0}^{n-1} \frac{c_i}{x - \beta ^{-i}} = \frac{x^{\delta - 1} p(x)}{x^n - 1}$$

o equivalentemente

$$\sum_{i=0}^{n-1} \frac{c_i}{x - \beta ^{-i}} \equiv 0 \pmod{x^{\delta - 1}}$$

La última equivalencia es la base para la definición de los códigos clásicos de Goppa.

Fijado el cuerpo de extensión $\mathbb{F}_{q^t}$ de $\mathbb{F}_q$, sea $L = \{ \gamma_0, ..., \gamma_{n-1} \}$ una tupla de $n$ elementos distintos de $\mathbb{F}_{q^t}$ y sea $g(x) \in \mathbb{F}_{q^t}[x]$ con $g(\gamma_i) \neq 0$ para $0 \leq i \leq n - 1$. Entonces el \emph{código de Goppa} $\Gamma(L,g)$ es el conjunto de vectores $c_0 \cdots c_{n-1} \in \mathbb{F}_q^n$ tal que 

\begin{equation}
    \label{def:goppa}
    \sum_{i=0}^{n-1} \frac{c_i}{x - \gamma_i} \equiv 0 \pmod{g(x)}
\end{equation}

De esta forma, cuando la parte de la izquierda está escrita como una función racional, significa que el numerador es un múltiplo de $g(x)$. Además, trabajar con módulo $g(x)$ es como trabajar en el anillo $\mathbb{F}_{q^t}[x]/(g(x))$, y la hipótesis $g(\gamma_i) \neq 0$ garantiza que $x - \gamma_i$ es invertible en este anillo. Se llama a $g(x)$ el \emph{polinomio de Goppa} de $\Gamma(L,g)$. Notemos que el código BCH de longitud $n$ y la distancia elegida $\delta$ es el código de Goppa $\Gamma(L,g)$ con $L = \{ 1, \beta^{-1}, ..., \beta^{1-n} \}$ y $g(x) = x^{\delta - 1}$.

A continuación, buscaremos una matriz de paridad para $\Gamma(L,g)$. Para ello, observamos que

$$\frac{1}{x - \gamma_i} \equiv - \frac{1}{g(\gamma_i)} \frac{g(x) - g(\gamma_i)}{x - \gamma_i} \pmod{ g(x)}$$

ya que, comparando numeradores, $1 \equiv - g(\gamma_i)^{-1} \left( g(x) - g(\gamma_i) \right) \pmod{g(x)}$. Así que por \eqref{def:goppa} $\textbf{c} = c_0 \cdots c_{n-1} \in \Gamma(L,g)$ si y solo si

\begin{equation}
    \label{congruencia_goppa}
    \sum_{i=0}^{n-1} c_i \frac{g(x) - g(\gamma_i)}{x - \gamma_i} g(\gamma_i)^{-1} \equiv 0 \pmod{g(x)}
\end{equation}

Supongamos que $g(x) = \sum_{j=0}^w g_j x^j$ con $g_j \in \mathbb{F}_{q^t}$, donde $w = gr(g(x))$. Entonces

$$\frac{g(x) - g(\gamma_i)}{x - \gamma_i} g(\gamma_i)^{-1} = g(\gamma_i)^{-1} \sum_{j=1}^w g_j \sum_{k=0}^{j-1} x^k \gamma_i^{j-1-k} = g(\gamma_i)^{-1} \sum_{k=0}^{w-1} x^k \left( \sum_{j=k+1}^w g_j \gamma_i^{j-1-k} \right)$$

Por lo tanto, por \eqref{congruencia_goppa}, estableciendo los coeficientes de $x^k$ iguales a $0$, en el orden $k = w - 1, w - 2, ..., 0$, tenemos que $\textbf{c} \in \Gamma(L,g)$ si y solo si $Hc^T = 0$, donde 

\begin{equation}
    H = \left(
        \begin{array}{ccc} 
            h_0 g_w & \cdots & h_{n-1} g_w  \\
            h_0 (g_{w-1} + g_w \gamma_0) & \cdots & h_{n-1} (g_{w-1} + g_w \gamma_{n-1}) \\
            & \vdots & \\
            h_0 \sum_{j=1}^w \left( g_j + \gamma_0^{j-1} \right) & \cdots & h_{n-1} \sum_{j=1}^w \left( g_{j} + \gamma_{n-1}^{j-1} \right) \\
        \end{array}
        \right)
\end{equation}

con $h_i = g(\gamma_i)^{-1}$.

\begin{proposition}
    La matriz $H$ se puede reducir a una matriz $H'$ de dimensión $w \times n$, donde 

    \begin{equation}
        H' = \left(
            \begin{array}{ccc} 
                g(\gamma_0)^{-1} & \cdots & g(\gamma_{n-1})^{-1}  \\
                g(\gamma_0)^{-1} \gamma_0 & \cdots & g(\gamma_{n-1})^{-1} \gamma_{n-1} \\
                & \vdots & \\
                g(\gamma_0)^{-1} \gamma_0^{w-1} & \cdots & g(\gamma_{n-1})^{-1} \gamma_{n-1}^{w-1} \\
            \end{array}
            \right)
    \end{equation}
\end{proposition}

Las entradas de $H'$ están en $\mathbb{F}_{q^t}$. Eligiendo una base de $\mathbb{F}_{q^t}$ sobre $\mathbb{F}_q$, cada elemento de $\mathbb{F}_{q^t}$ se puede representar como un vector columna $t \times 1$ sobre $\mathbb{F}_q$. Reemplazando cada entrada de $H'$ por su correspondiente vector columna, obtenemos una matriz $H''$ de dimensión $tw \times n$ sobre $\mathbb{F}_{q}$ que tiene la propiedad de que si $\textbf{c} \in \mathbb{F}_q^n$ está en $\Gamma(L,g)$ si y solo si $H''c^T = 0$.

El siguiente resultado nos muestra los límites en la dimensión y la distancia mínima de un código de Goppa.

\begin{theorem}
    \label{th:dist_min_Goppa}
    Con la notación de esta sección, sea $\Gamma(L,g)$ un código de Goppa tal que $gr(g(x)) = w$ entonces es un $[n, k, d]$ código con $k \geq n - wt$ y $d \geq w + 1$.
\end{theorem}

\begin{proof}
    Las filas de $H''$ pueden ser dependientes, luego esta matriz tiene rango como máximo $wt$. Por lo que $\Gamma(L,g)$ tiene dimensión al menos $n - wt$. Si una palabra código $\textbf{c} \in \Gamma(L,g)$ tiene peso $w$ o menos, entonces el lado izquierdo de \ref{def:goppa} es una función racional, donde el numerador tiene grado $w - 1$ o menos; pero este numerador tiene que ser múltiplo de $g(x)$, lo cual es una contradicción pues el grado de $g$ es $w$.
\end{proof}

\begin{corollary}
    Si $\Gamma(L,g)$ es un código de Goppa tal que $gr(g(x)) = w$, entonces puede corregir hasta

    $$\left\lfloor \frac{w}{2} \right\rfloor $$

    errores.
\end{corollary}

\begin{proof}
    El teorema \ref{th:decodificacion_maxima_verosimilitud} afirma que es posible corregir hasta 
    
    $$\left\lfloor \frac{d(\Gamma(L,g)) - 1}{2} \right\rfloor$$

    errores. Además, por el teorema \ref{th:dist_min_Goppa} sabemos que la distancia mínima de un código de Goppa $\Gamma(L,g)$ tal que $gr(g(x)) = w$ es $d(\Gamma(L,g)) = w + 1$. Por lo que

    $$\left\lfloor \frac{d(\Gamma(L,g)) - 1}{2} \right\rfloor = \left\lfloor \frac{(w + 1) - 1}{2} \right\rfloor = \left\lfloor \frac{w}{2} \right\rfloor .$$
\end{proof}

\subsection{Códigos binarios de Goppa}

Los códigos binarios de Goppa son códigos de corrección de errores que pertenecen a la clase de los códigos de Goppa que acabamos de estudiar. La estructura binaria le da más ventajas matemáticas sobre variantes no binarias y, además, tienen propiedades interesantes adecuadas para la construcción del criptosistema McEliece.

\begin{definition}

    Fijado el cuerpo de extensión $\mathbb{F}_{2^m}$ de $\mathbb{F}_2$, sea $L = \{ \gamma_0, ..., \gamma_{n-1} \} \in \mathbb{F}_{2^m}^n$ una tupla de $n$ elementos distintos de $\mathbb{F}_{2^m}$ y sea $g(x) \in \mathbb{F}_{2^m}[x]$ con $g(\gamma_i) \neq 0$ para $0 \leq i \leq n - 1$. Entonces el \emph{código binario de Goppa} $\Gamma(L,g)$ es el conjunto de vectores $c_0 \cdots c_{n-1} \in \{ 0, 1 \}^n$ tal que 

    \begin{equation}
        \sum_{i=0}^{n-1} \frac{c_i}{x - \gamma_i} \equiv 0 \pmod{g(x)}
    \end{equation}
\end{definition}

Observemos que si $g(x)$ es un polinomio irreducible, todos los elementos $\gamma \in \mathbb{F}_{2^m}$ satisfacen $g(\gamma) \neq 0$. A los códigos que cumplan esta propiedad los llamaremos \emph{códigos binarios de Goppa irreducibles}.

En los siguientes resultados se enuncian las propiedades de los códigos binarios de Goppa, que tienen ciertas diferencias con los generales.

\begin{theorem}
    Sea $\Gamma(L,g)$ un código binario de Goppa tal que $gr(g(x)) = w$ entonces es un $[n, k, d]$ código con $k \geq n - wt$ y $d \geq 2w + 1$.
\end{theorem}

\begin{corollary}
    Si $\Gamma(L,g)$ es un código de Goppa tal que $gr(g(x)) = w$, entonces puede corregir hasta

    $$\left\lfloor \frac{(2w + 1) - 1}{2} \right\rfloor $$

    errores.
\end{corollary}

Observamos que con estos códigos podemos doblar la capacidad correctora de los códigos generales de Goppa.


\subsection{Decodificación de los códigos de Goppa}

Como hemos visto, al transmitir una palabra código a un receptor, éste podría recibir la palabra alterada. Para que el receptor pueda determinar el mensaje original, necesitaremos decodificar el mensaje recibido. Supongamos que $E$ es el vector de errores que se añade a la palabra código $C$ transmitida, entonces la palabra recibida $R$ está dada por

$$R = C + E$$

de donde 

$$\sum_{\gamma \in L} \frac{R_\gamma}{x - \gamma} = \sum_{\gamma \in L} \frac{C_\gamma}{x - \gamma} + \sum_{\gamma \in L} \frac{E_\gamma}{x - \gamma}.$$

Como $C$ es una palabra código, la primera sumatoria de la parte derecha desaparece al aplicar el módulo $g(x)$, y tenemos que

$$\sum_{\gamma \in L} \frac{R_\gamma}{x - \gamma} = \sum_{\gamma \in L} \frac{E_\gamma}{x - \gamma} \pmod{g(x)}.$$

Definiremos su síndrome como el polinomio $S(x)$ de grado menos que $gr(g(x))$ tal que 

$$S(x) = \sum_{\gamma \in L} \frac{R_\gamma}{x - \gamma} \pmod{g(x)}.$$

Acabamos de ver que 

$$S(x) = \sum_{\gamma \in L} \frac{E_\gamma}{x - \gamma} \pmod{g(x)}.$$

Sea $M$ un subconjunto de $L$ tal que $E_{\gamma} \neq 0$ si y solo si $\gamma \in M$. Entonces

\begin{equation}
    \label{def:sindrome}
    S(x) = \sum_{\gamma \in M} \frac{E_\gamma}{x - \gamma} \pmod{g(x)}.
\end{equation}

De esta forma, ahora podemos introducir el polinomio cuyas raíces son las ubicaciones de los errores,

\begin{equation}
    \label{def:localizaciones}
    \sigma (x) = \prod_{\gamma \in M} (x - \gamma)
\end{equation}

Sin embargo, para los códigos de Goppa es más conveniente definir una variante de este polinomio de la siguiente forma.

\begin{equation}
    \label{def:eta}
    \eta (x) = \sum_{\gamma \in M} E_\gamma \prod_{\partial \in M \setminus \{ \gamma \} } (x - \partial)
\end{equation}

Observemos que de esta forma $\sigma(x)$ y $\eta(x)$ deben ser primos relativos.

Derivando la expresión de $\sigma(x)$, tenemos que 

\begin{equation}
    \label{def:localizaciones_derivada}
    \sigma'(x) = \sum_{\gamma \in M} \prod_{\partial \in M \setminus \{ \gamma \} } (x - \partial)
\end{equation}


de donde, para cada $\gamma \in M$,

$$\eta (\gamma) = E_\gamma \prod_{\partial \in M \setminus \{ \gamma \} } (\gamma - \partial) = E_\gamma \sigma'(\gamma)$$

por lo que $E_\gamma = \frac{\eta(\gamma)}{\sigma'(\gamma)}$. De esta forma, una vez que hemos calculado los polinomios $\sigma$ y $\eta$, las coordenadas del vector error vienen dadas por 

\[
    E_\gamma = \left\{ \begin{array}{lcc}
    0 &   \text{si}  & \sigma(\gamma) \neq 0 \\
    \\ \frac{\eta(\gamma)}{\sigma'(\gamma)} &  \text{si} & \sigma(\gamma) = 0
    \end{array}
    \right.
\]

donde $\sigma'(x)$ es la derivada de $\sigma(x)$.

Lo esencial para decodificar los códigos de Goppa es determinar los coeficientes de los polinomios $\sigma$ y $\eta$. Para ello, tenemos que relacionar $\sigma$ y $\eta$ al síndrome de la ecuación \ref{def:sindrome}. Esto se consigue multiplicando las ecuaciones \ref{def:sindrome} y \ref{def:localizaciones}, obteniendo

\begin{equation}
    \label{prop:key_equation}
    S(x) \cdot \sigma(x) \equiv \eta(x) \pmod{g(x)}
\end{equation}

La ecuación \ref{prop:key_equation} es la \emph{ecuación clave} para decodificar los códigos de Goppa. Dado $g(x)$ y $S(x)$, el problema de decodificar consiste en encontrar polinomios de grado bajo $\sigma(x)$ y $\eta(x)$ que satisfacen \ref{prop:key_equation}.

Reduciendo cada potencia de $x \pmod{g(x)}$ e igualando coeficientes de $1, x, ..., x^{gr g - 1}$, tenemos que \ref{prop:key_equation} es un sistema de $gr G$ ecuaciones lineales donde las incógnitas son los coeficientes de $\sigma$ y $\eta$. Por lo tanto, para probar que el decodificador es capaz de corregir todos los patrones hasta $t$ errores, basta con probar que \ref{prop:key_equation} tiene una única solución con grados de $\sigma$ y de $\eta$ suficientemente pequeños. Esto equivale a que el conjunto de ecuaciones lineales correspondientes sean linealmente independientes.

Supongamos que existen dos pares diferentes de soluciones a \ref{prop:key_equation}:

\begin{equation}
    \label{prop:key_equation_1}
    S(x) \sigma^{(1)}(x) \equiv \eta^{(1)}(x) \pmod{g(x)}
\end{equation}

\begin{equation}
    \label{prop:key_equation_2}
    S(x) \sigma^{(2)}(x) \equiv \eta^{(2)}(x) \pmod{g(x)}
\end{equation}

donde $\sigma^{(1)}(x)$ y $\eta^{(1)}(x)$ son primos relativos, al igual que $\sigma^{(2)}(x)$ y $\eta^{(2)}(x)$. Además, $\sigma^{(1)}(x)$ y $g(x)$ no pueden tener ningún factor en común, pues en ese caso ese factor podría dividir a $\eta^{(1)}(x)$, contradiciendo que $\sigma^{(1)}(x)$ y $\eta^{(1)}(x)$ son primos relativos. Así, podemos dividir \ref{prop:key_equation_1} por $\sigma^{(1)}(x)$ y obtenemos

$$S(x) \equiv \frac{\eta^{(1)}(x)}{\sigma^{(1)}(x)} \pmod{g(x)}$$

de la misma forma para \ref{prop:key_equation_2},

$$S(x) \equiv \frac{\eta^{(2)}(x)}{\sigma^{(2)}(x)} \pmod{g(x)}$$

de donde,

\begin{equation}
    \label{prop:key_equation_12}
    \sigma^{(1)}(x) \eta^{(2)}(x) \equiv \sigma^{(2)}(x) \eta^{(1)}(x) \pmod{g(x)}
\end{equation}

Si $gr(G) = 2t$ y $gr(\sigma^{(1)}) \leq t$, $gr(\sigma^{(2)}) \leq t$, $gr(\eta^{(2)}) < t$ y $gr(\eta^{(1)}) < t$, entonces se da la siguiente igualdad

\begin{equation}
    \label{prop:key_equation_caso1}
    \sigma^{(1)}(x) \eta^{(2)}(x) = \sigma^{(2)}(x) \eta^{(1)}(x)
\end{equation}

Así, $\sigma^{(1)}$ divide a $\sigma^{(2)} \eta^{(1)}$, y como $\sigma^{(1)}$ y $\eta^{(1)}$ son primos relativos, $\sigma^{(1)}$ tiene que dividir a $\sigma^{(2)}$. Análogamente, $\sigma^{(2)}$ tiene que dividir a $\sigma^{(1)}$. Como ambos son mónicos, se tiene que $\sigma^{(1)} = \sigma^{(2)}$ y así, $\eta^{(1)} = \eta^{(2)}$. Con esto hemos probado que si el grado de $G$ es $2t$, entonces \ref{prop:key_equation} tiene una única solución cuando $gr(\eta) < gr(\sigma) \leq t$, luego el correspondiente sistema de ecuaciones lineales donde las incógnitas son los coeficientes de $\sigma$ y $\eta$ tiene que ser no singular. En el siguiente teorema se concluye este resultado.

\begin{theorem}
    Si $gr(g(x)) = 2t$, entonces hay un algoritmo de decodificación algebraica de corrección de $t$ errores para el código q-ario de Goppa con el polinomio de Goppa $g(x)$.
\end{theorem}

Estudiemos ahora este resultado en el caso binario, primero observamos que ya que todos los $E_\gamma$ distintos de cero son iguales a 1, entonces \ref{def:eta} y \ref{def:localizaciones_derivada} coincidan. De esta forma, la ecuación \ref{prop:key_equation_12} ahora pasa a ser

$$\sigma^{(1)} \left( \sigma^{(2)} \right) ' \equiv \sigma^{(2)} \left( \sigma^{(1)} \right) ' \pmod{g(x)}$$

Ahora, cuando $\sigma$ sea par escribiremos en su lugar $\hat{\sigma}$, mientras que cuando $\sigma$ sea impar escribiremos en su lugar $x \sigma '$. Así, tenemos que

\begin{align*} 
    \left( \hat{\sigma}^{(1)} + x \sigma^{(1)'} \right) \sigma^{(2)'} &\equiv \left( \hat{\sigma}^{(2)} + x \sigma^{(2)'} \right) \sigma^{(1)'}\\ 
    \hat{\sigma}^{(1)} \sigma^{(2)'} + \hat{\sigma}^{(2)} \sigma^{(1)'} &\equiv 0 \pmod{g(x)}.
\end{align*}

El lado izquierdo es un cuadrado perfecto, pues todos los polinomios de ese lado son pares. Esto implica que

$$\hat{\sigma}^{(1)} \sigma^{(2)'} + \hat{\sigma}^{(2)} \sigma^{(1)'} \equiv 0 \pmod{\bar{G}(x)}$$

donde $\bar{G}(x)$ es múltiplo de $g(x)$ de menor grado ya que $\bar{G}$ es un cuadrado perfecto. Por lo que, si $gr(\bar{G}) = 2t$, $gr(\sigma^{(1)}) \leq t$ y $gr(\sigma^{(2)}) \leq t$, entonces 

$$\hat{\sigma}^{(1)} \left( \sigma^{(2)} \right) ' = \hat{\sigma}^{(2)} \sigma^{(1)'}.$$

Por la primalidad relativa, $\sigma^{(1)} = \sigma^{(2)}$. En el siguiente teorema se concluye este resultado.

\begin{theorem}
    Si $gr(g(x)) = t$ y si $g(x)$ no tiene factores irreducibles repetidos, entonces hay un algoritmo de decodificación algebraica de corrección de $t$ errores para el código binario de Goppa con el polinomio de Goppa $g(x)$.
\end{theorem}


% 2. Códigos de Goppa.
% Esto lo puedes encontrar en el capítulo 13 de Huffman y Pless. 
% La decodificación  de estos códigos, es similar a la de los códigos BCH (capítulo 5) utilizando el algoritmo de Sugiyama. 
% El artículo donde se definen y se decodifican es el de Goppa.pdf. 
% Además, ahi se explica de forma elemental, sin utilizar geometría algebraica.

\chapter{Códigos de Goppa}

% TODO: introduccion
\textcolor{red}{Hay que completar esta introducción}

En \cite{Goppa_codes_1973}, Goppa describió una nueva clase de códigos de corrección de errores lineales. Lo más importante es que algunos de estos códigos excedían el límite asintótico de Gilbert-Varshamov, una hazaña que muchos teóricos códigos pensaban que nunca podría lograrse. En este capítulo vamos a hablar sobre los códigos de Goppa y sus propiedades más importantes.

El desarrollo de este capítulo se ha basado en \cite{Huffman_Pless_2010} y \cite{Goppa_codes_1973}.

\section{Códigos clásicos de Goppa}

Fijado el cuerpo de extensión $\mathbb{F}_{q^t}$ de $\mathbb{F}_q$, sea $L = \{ \gamma_0, ..., \gamma_{n-1} \}$ una tupla de $n$ elementos distintos de $\mathbb{F}_{q^t}$ y sea $g(x) \in \mathbb{F}_{q^t}[x]$ con $g(\gamma_i) \neq 0$ para $0 \leq i \leq n - 1$. Entonces el \emph{código de Goppa} $\Gamma(L,g)$ es el conjunto de vectores $c_0 \cdots c_{n-1} \in \mathbb{F}_q^n$ tal que 

\begin{equation}
    \label{def:goppa}
    \sum_{i=0}^{n-1} \frac{c_i}{x - \gamma_i} \equiv 0 \pmod{g(x)}
\end{equation}

De esta forma, cuando la parte de la izquierda está escrita como una función racional, significa que el numerador es un múltiplo de $g(x)$. Además, trabajar módulo $g(x)$ es como trabajar en el anillo $\mathbb{F}_{q^t}[x]/(g(x))$, y la hipótesis $g(\gamma_i) \neq 0$ garantiza que $x - \gamma_i$ es invertible en este anillo. Se llama a $g(x)$ el \emph{polinomio de Goppa} de $\Gamma(L,g)$. Notemos que el código BCH de longitud $n$ y la distancia elegida $\delta$ es el código de Goppa $\Gamma(L,g)$ con $L = \{ 1, \beta^{-1}, ..., \beta^{1-n} \}$ y $g(x) = x^{\delta - 1}$.

A continuación, buscaremos una matriz de paridad para $\Gamma(L,g)$. Para ello, observamos que

$$\frac{1}{x - \gamma_i} \equiv - \frac{1}{g(\gamma_i)} \frac{g(x) - g(\gamma_i)}{x - \gamma_i} \pmod{ g(x)}$$

ya que, comparando numeradores, $1 \equiv - g(\gamma_i)^{-1} \left( g(x) - g(\gamma_i) \right) \pmod{g(x)}$. Así que por \eqref{def:goppa} $\textbf{c} = c_0 \cdots c_{n-1} \in \Gamma(L,g)$ si y solo si

\begin{equation}
    \label{congruencia_goppa}
    \sum_{i=0}^{n-1} c_i \frac{g(x) - g(\gamma_i)}{x - \gamma_i} g(\gamma_i)^{-1} \equiv 0 \pmod{g(x)}
\end{equation}

Supongamos que $g(x) = \sum_{j=0}^w g_j x^j$ con $g_j \in \mathbb{F}_{q^t}$, donde $w = gr(g(x))$. Entonces

$$\frac{g(x) - g(\gamma_i)}{x - \gamma_i} g(\gamma_i)^{-1} = g(\gamma_i)^{-1} \sum_{j=1}^w g_j \sum_{k=0}^{j-1} x^k \gamma_i^{j-1-k} = g(\gamma_i)^{-1} \sum_{k=0}^{w-1} x^k \left( \sum_{j=k+1}^w g_j \gamma_i^{j-1-k} \right)$$

Por lo tanto, por \eqref{congruencia_goppa}, estableciendo los coeficientes de $x^k$ iguales a $0$, en el orden $k = w - 1, w - 2, ..., 0$, tenemos que $\textbf{c} \in \Gamma(L,g)$ si y solo si $Hc^T = 0$, donde 

\begin{equation}
    H = \left(
        \begin{array}{ccc} 
            h_0 g_w & \cdots & h_{n-1} g_w  \\
            h_0 (g_{w-1} + g_w \gamma_0) & \cdots & h_{n-1} (g_{w-1} + g_w \gamma_{n-1}) \\
            & \vdots & \\
            h_0 \sum_{j=1}^w \left( g_j + \gamma_0^{j-1} \right) & \cdots & h_{n-1} \sum_{j=1}^w \left( g_{j} + \gamma_{n-1}^{j-1} \right) \\
        \end{array}
        \right)
\end{equation}

con $h_i = g(\gamma_i)^{-1}$.

\begin{proposition}
    La matriz $H$ se puede reducir a una matriz $H'$ de dimensión $w \times n$, donde 

    \begin{equation}
        H' = \left(
            \begin{array}{ccc} 
                g(\gamma_0)^{-1} & \cdots & g(\gamma_{n-1})^{-1}  \\
                g(\gamma_0)^{-1} \gamma_0 & \cdots & g(\gamma_{n-1})^{-1} \gamma_{n-1} \\
                & \vdots & \\
                g(\gamma_0)^{-1} \gamma_0^{w-1} & \cdots & g(\gamma_{n-1})^{-1} \gamma_{n-1}^{w-1} \\
            \end{array}
            \right)
    \end{equation}
\end{proposition}

Las entradas de $H'$ están en $\mathbb{F}_{q^t}$. Eligiendo una base de $\mathbb{F}_{q^t}$ sobre $\mathbb{F}_q$, cada elemento de $\mathbb{F}_{q^t}$ se puede representar como un vector columna $t \times 1$ sobre $\mathbb{F}_q$. Reemplazando cada entrada de $H'$ por su correspondiente vector columna, obtenemos una matriz $H''$ de dimensión $tw \times n$ sobre $\mathbb{F}_{q}$ que tiene la propiedad de que $\textbf{c} \in \mathbb{F}_q^n$ está en $\Gamma(L,g)$ si y solo si $H''c^T = 0$.

El siguiente resultado nos muestra los límites en la dimensión y la distancia mínima de un código de Goppa.

\begin{theorem}
    \label{th:dist_min_Goppa}
    Con la notación de esta sección, sea $\Gamma(L,g)$ un código de Goppa tal que $gr(g(x)) = w$ entonces es un $[n, k, d]$ código con $k \geq n - wt$ y $d \geq w + 1$.
\end{theorem}

\begin{proof}
    Las filas de $H''$ pueden ser dependientes, luego esta matriz tiene rango como máximo $wt$. Por lo que $\Gamma(L,g)$ tiene dimensión al menos $n - wt$. Si una palabra código $\textbf{c} \in \Gamma(L,g)$ tiene peso $w$ o menos, entonces el lado izquierdo de \ref{def:goppa} es una función racional, donde el numerador tiene grado $w - 1$ o menos; pero este numerador tiene que ser múltiplo de $g(x)$, lo cual es una contradicción pues el grado de $g$ es $w$.
\end{proof}

\begin{corollary}
    Si $\Gamma(L,g)$ es un código de Goppa tal que $gr(g(x)) = w$, entonces puede corregir hasta

    $$\left\lfloor \frac{w}{2} \right\rfloor $$

    errores.
\end{corollary}

\begin{proof}
    El teorema \ref{th:decodificacion_maxima_verosimilitud} afirma que es posible corregir hasta 
    
    $$\left\lfloor \frac{d(\Gamma(L,g)) - 1}{2} \right\rfloor$$

    errores. Además, por el teorema \ref{th:dist_min_Goppa} sabemos que la distancia mínima de un código de Goppa $\Gamma(L,g)$ tal que $gr(g(x)) = w$ es $d(\Gamma(L,g)) = w + 1$. Por lo que

    $$\left\lfloor \frac{d(\Gamma(L,g)) - 1}{2} \right\rfloor = \left\lfloor \frac{(w + 1) - 1}{2} \right\rfloor = \left\lfloor \frac{w}{2} \right\rfloor .$$
\end{proof}

\subsection{Códigos binarios de Goppa}

Los códigos binarios de Goppa son códigos de corrección de errores que pertenecen a la clase de los códigos de Goppa que acabamos de estudiar. La estructura binaria le da más ventajas matemáticas sobre variantes no binarias y, además, tienen propiedades interesantes adecuadas para la construcción del criptosistema McEliece.

\begin{definition}

    Fijada la extensión de cuerpos $\mathbb{F}_{2^m}$ de $\mathbb{F}_2$, sea $L = \{ \gamma_0, ..., \gamma_{n-1} \} \in \mathbb{F}_{2^m}^n$ una tupla de $n$ elementos distintos de $\mathbb{F}_{2^m}$ y sea $g(x) \in \mathbb{F}_{2^m}[x]$ con $g(\gamma_i) \neq 0$ para $0 \leq i \leq n - 1$. Entonces el \emph{código binario de Goppa} $\Gamma(L,g)$ es el conjunto de vectores $c_0 \cdots c_{n-1} \in \{ 0, 1 \}^n$ tal que 

    \begin{equation}
        \sum_{i=0}^{n-1} \frac{c_i}{x - \gamma_i} \equiv 0 \pmod{g(x)}
    \end{equation}
\end{definition}

Observemos que si $g(x)$ es un polinomio irreducible, todos los elementos $\gamma \in \mathbb{F}_{2^m}$ satisfacen $g(\gamma) \neq 0$. A los códigos que cumplan esta propiedad los llamaremos \emph{códigos binarios de Goppa irreducibles}.

La importancia de estos códigos se debe a que pueden doblar la capacidad correctora de los códigos generales de Goppa.

\subsection{Decodificación de los códigos de Goppa}

Como hemos visto, al transmitir una palabra código a un receptor, éste podría recibir la palabra alterada. Para que el receptor pueda determinar el mensaje original, necesitaremos decodificar el mensaje recibido. Sea $\Gamma(L,g)$ un código de Goppa, donde $L = \{ \gamma_0, ..., \gamma_{n-1} \}$ es una tupla de $n$ elementos distintos de $\mathbb{F}_{q^t}$. Supongamos que $e$ es el vector de errores que se añade a la palabra código $c$ transmitida, entonces la palabra recibida $y$ está dada por

$$y = c + e$$

de donde 

$$\sum_{\gamma \in L} \frac{y_\gamma}{x - \gamma} = \sum_{\gamma \in L} \frac{c_\gamma}{x - \gamma} + \sum_{\gamma \in L} \frac{e_\gamma}{x - \gamma}.$$

Como $c$ es una palabra código, la primera sumatoria de la parte derecha desaparece al aplicar el módulo $g(x)$, y tenemos que

$$\sum_{\gamma \in L} \frac{y_\gamma}{x - \gamma} = \sum_{\gamma \in L} \frac{e_\gamma}{x - \gamma} \pmod{g(x)}.$$

Definiremos su síndrome como el polinomio $S(x)$ de grado menos que $gr(g(x))$ tal que 

$$S(x) = \sum_{\gamma \in L} \frac{y_\gamma}{x - \gamma} \pmod{g(x)}.$$

Acabamos de ver que 

$$S(x) = \sum_{\gamma \in L} \frac{e_\gamma}{x - \gamma} \pmod{g(x)}.$$

Sea $M$ un subconjunto de $L$ tal que $e_{\gamma} \neq 0$ si y solo si $\gamma \in M$. Entonces

\begin{equation}
    \label{def:sindrome}
    S(x) = \sum_{\gamma \in M} \frac{e_\gamma}{x - \gamma} \pmod{g(x)}.
\end{equation}

De esta forma, ahora podemos introducir el polinomio cuyas raíces son las ubicaciones de los errores,

\begin{equation}
    \label{def:localizaciones}
    \sigma (x) = \prod_{\gamma \in M} (x - \gamma)
\end{equation}

Sin embargo, para los códigos de Goppa es más conveniente definir una variante de este polinomio de la siguiente forma.

\begin{equation}
    \label{def:eta}
    \eta (x) = \sum_{\gamma \in M} e_\gamma \prod_{\partial \in M \setminus \{ \gamma \} } (x - \partial)
\end{equation}

Observemos que de esta forma $\sigma(x)$ y $\eta(x)$ deben ser primos relativos.

Derivando la expresión de $\sigma(x)$, tenemos que 

\begin{equation}
    \label{def:localizaciones_derivada}
    \sigma'(x) = \sum_{\gamma \in M} \prod_{\partial \in M \setminus \{ \gamma \} } (x - \partial)
\end{equation}


de donde, para cada $\gamma \in M$,

$$\eta (\gamma) = e_\gamma \prod_{\partial \in M \setminus \{ \gamma \} } (\gamma - \partial) = e_\gamma \sigma'(\gamma)$$

por lo que $e_\gamma = \frac{\eta(\gamma)}{\sigma'(\gamma)}$. De esta forma, una vez que hemos calculado los polinomios $\sigma$ y $\eta$, las coordenadas del vector error vienen dadas por 

\[
    e_\gamma = \left\{ \begin{array}{lcc}
    0 &   \text{si}  & \sigma(\gamma) \neq 0 \\
    \\ \frac{\eta(\gamma)}{\sigma'(\gamma)} &  \text{si} & \sigma(\gamma) = 0
    \end{array}
    \right.
\]

donde $\sigma'(x)$ es la derivada de $\sigma(x)$.

Lo esencial para decodificar los códigos de Goppa es determinar los coeficientes de los polinomios $\sigma$ y $\eta$. Para ello, tenemos que relacionar $\sigma$ y $\eta$ al síndrome de la ecuación \ref{def:sindrome}. Esto se consigue multiplicando las ecuaciones \ref{def:sindrome} y \ref{def:localizaciones}, obteniendo

\begin{equation}
    \label{prop:key_equation}
    S(x) \cdot \sigma(x) \equiv \eta(x) \pmod{g(x)}
\end{equation}

La ecuación \ref{prop:key_equation} es la \emph{ecuación clave} para decodificar los códigos de Goppa. Dado $g(x)$ y $S(x)$, el problema de decodificar consiste en encontrar polinomios de grado bajo $\sigma(x)$ y $\eta(x)$ que satisfacen \ref{prop:key_equation}.

Reduciendo cada potencia de $x \pmod{g(x)}$ e igualando coeficientes de $1, x, ..., x^{gr(g) - 1}$, tenemos que \ref{prop:key_equation} es un sistema de $gr(G)$ ecuaciones lineales donde las incógnitas son los coeficientes de $\sigma$ y $\eta$. Por lo tanto, para probar que el decodificador es capaz de corregir todos los patrones hasta $t$ errores, basta con probar que \ref{prop:key_equation} tiene una única solución con grados de $\sigma$ y de $\eta$ suficientemente pequeños. Esto equivale a que el conjunto de ecuaciones lineales correspondientes sean linealmente independientes.

Supongamos que existen dos pares diferentes de soluciones a \ref{prop:key_equation}:

\begin{equation}
    \label{prop:key_equation_1}
    S(x) \sigma^{(1)}(x) \equiv \eta^{(1)}(x) \pmod{g(x)}
\end{equation}

\begin{equation}
    \label{prop:key_equation_2}
    S(x) \sigma^{(2)}(x) \equiv \eta^{(2)}(x) \pmod{g(x)}
\end{equation}

donde $\sigma^{(1)}(x)$ y $\eta^{(1)}(x)$ son primos relativos, al igual que $\sigma^{(2)}(x)$ y $\eta^{(2)}(x)$. Además, $\sigma^{(1)}(x)$ y $g(x)$ no pueden tener ningún factor en común, pues en ese caso ese factor podría dividir a $\eta^{(1)}(x)$, contradiciendo que $\sigma^{(1)}(x)$ y $\eta^{(1)}(x)$ son primos relativos. Así, podemos dividir \ref{prop:key_equation_1} por $\sigma^{(1)}(x)$ y obtenemos

$$S(x) \equiv \frac{\eta^{(1)}(x)}{\sigma^{(1)}(x)} \pmod{g(x)}$$

de la misma forma para \ref{prop:key_equation_2},

$$S(x) \equiv \frac{\eta^{(2)}(x)}{\sigma^{(2)}(x)} \pmod{g(x)}$$

de donde,

\begin{equation}
    \label{prop:key_equation_12}
    \sigma^{(1)}(x) \eta^{(2)}(x) \equiv \sigma^{(2)}(x) \eta^{(1)}(x) \pmod{g(x)}
\end{equation}

Si $gr(G) = 2t$ y $gr(\sigma^{(1)}) \leq t$, $gr(\sigma^{(2)}) \leq t$, $gr(\eta^{(2)}) < t$ y $gr(\eta^{(1)}) < t$, entonces se da la siguiente igualdad

\begin{equation}
    \label{prop:key_equation_caso1}
    \sigma^{(1)}(x) \eta^{(2)}(x) = \sigma^{(2)}(x) \eta^{(1)}(x)
\end{equation}

Así, $\sigma^{(1)}$ divide a $\sigma^{(2)} \eta^{(1)}$, y como $\sigma^{(1)}$ y $\eta^{(1)}$ son primos relativos, $\sigma^{(1)}$ tiene que dividir a $\sigma^{(2)}$. Análogamente, $\sigma^{(2)}$ tiene que dividir a $\sigma^{(1)}$. Como ambos son mónicos, se tiene que $\sigma^{(1)} = \sigma^{(2)}$ y así, $\eta^{(1)} = \eta^{(2)}$. Con esto hemos probado que si el grado de $G$ es $2t$, entonces \ref{prop:key_equation} tiene una única solución cuando $gr(\eta) < gr(\sigma) \leq t$, luego el correspondiente sistema de ecuaciones lineales donde las incógnitas son los coeficientes de $\sigma$ y $\eta$ tiene que ser no singular. En el siguiente teorema se concluye este resultado.

\begin{theorem}
    Si $gr(g(x)) = 2t$, entonces hay un algoritmo de decodificación algebraica de corrección de $t$ errores para el código q-ario de Goppa con el polinomio de Goppa $g(x)$.
\end{theorem}

Estudiemos ahora este resultado en el caso binario, primero observamos que ya que todos los $e_\gamma$ distintos de cero son iguales a 1, entonces \ref{def:eta} y \ref{def:localizaciones_derivada} coincidan. De esta forma, la ecuación \ref{prop:key_equation_12} ahora pasa a ser

$$\sigma^{(1)} \left( \sigma^{(2)} \right) ' \equiv \sigma^{(2)} \left( \sigma^{(1)} \right) ' \pmod{g(x)}$$

Ahora, cuando $\sigma$ sea par escribiremos en su lugar $\hat{\sigma}$, mientras que cuando $\sigma$ sea impar escribiremos en su lugar $x \sigma '$. Así, tenemos que

\begin{align*} 
    \left( \hat{\sigma}^{(1)} + x \sigma^{(1)'} \right) \sigma^{(2)'} &\equiv \left( \hat{\sigma}^{(2)} + x \sigma^{(2)'} \right) \sigma^{(1)'}\\ 
    \hat{\sigma}^{(1)} \sigma^{(2)'} + \hat{\sigma}^{(2)} \sigma^{(1)'} &\equiv 0 \pmod{g(x)}.
\end{align*}

El lado izquierdo es un cuadrado perfecto, pues todos los polinomios de ese lado son pares. Esto implica que

$$\hat{\sigma}^{(1)} \sigma^{(2)'} + \hat{\sigma}^{(2)} \sigma^{(1)'} \equiv 0 \pmod{\bar{G}(x)}$$

donde $\bar{G}(x)$ es múltiplo de $g(x)$ de menor grado ya que $\bar{G}$ es un cuadrado perfecto. Por lo que, si $gr(\bar{G}) = 2t$, $gr(\sigma^{(1)}) \leq t$ y $gr(\sigma^{(2)}) \leq t$, entonces 

$$\hat{\sigma}^{(1)} \left( \sigma^{(2)} \right) ' = \hat{\sigma}^{(2)} \sigma^{(1)'}.$$

Por la primalidad relativa, $\sigma^{(1)} = \sigma^{(2)}$. En el siguiente teorema se concluye este resultado.

\begin{theorem}
    Si $gr(g(x)) = t$ y si $g(x)$ no tiene factores irreducibles repetidos, entonces hay un algoritmo de decodificación algebraica de corrección de $t$ errores para el código binario de Goppa con el polinomio de Goppa $g(x)$.
\end{theorem}

\subsubsection{Algoritmo de decodificación de Sugiyama}

El algoritmo de Sugiyama es una aplicación simple del algoritmo de Euclides para determinar el polinomio localizador de errores de una manera más eficiente.

Dado $g(x)$ un polinomio de Goppa con grado $2t$, el algoritmo de decodificación de Sugiyama para los códigos Goppa es el siguiente.

\begin{itemize}
    \item[I.] Calcular el síndrome $S(x)$.
    \item[II.] Sean $r_{-1}(x) = g(x)$, $r_0(x) = S(x)$, $U_{-1}(x) = 0$ y $U_0(x) = 1$.
    \item[III.] Buscar $q_i(x)$ y $r_i(x)$ aplicando el algoritmo de Euclides para encontrar el máximo común divisor de $r_{-1}(x)$ y $r_0(x)$ para $i = 1,..., k$, hasta que $k$ cumpla que $gr(r_{k-1}(x)) \geq t$ y $gr(r_k(x)) < t$:

        $$r_{i-2}(x) = r_{i-1}(x) q_i(x) + r_i(x), \qquad gr(r_i(x)) < gr(r_{i-1})(x)$$
    
    \item[IV.] Calcular $U_k(x)$, donde
    
        $$U_i(x) = q_i(x) U_{i-1}(x) + U_{i-2}(x)$$

    \item[V.] La solución viene dada por:
        $$\eta(x) = (-1)^k \delta r_k(x)$$
        $$\sigma(x) = \delta U_k(x)$$
\end{itemize}


\begin{comment}
El algoritmo de Sugiyama es el siguiente:

\begin{itemize}
    \item[I.] Sean $f(x) = x^{2t}$, $s(x) = S(x)$, $r_{-1}(x) = f(x)$, $r_0(x) = s(x)$, $b_{-1}(x) = 0$ y $b_0(x) = 1$.
    \item[II.] Iterar incrementando en una unidad desde $i = 1$ hasta $I$, de forma que se cumpla que $gr(r_{I-1}(x)) \geq t$ y $gr(r_I(x)) < t$. En cada iteración habrá que determinar $h_i(x)$, $r_i(x)$ y $b_i(x)$:
        $$r_{i-2}(x) = r_{i-1}(x) h_i(x) + r_i (x), \qquad \text{ donde } gr(r_i(x)) < gr(r_{i-1}(x)),$$
        $$b_i(x) = b_{i-2}(x) - h_i(x) b_{i-1}(x).$$
    \item[III.] $\sigma(x)$ es un escalar no nulo múltiplo de $b_I(x)$. 
\end{itemize}

Para verificar que este algoritmo funciona, el siguiente lema nos será de utilidad.

\begin{lemma}
    \label{lm:dem_sugiyama}
    Con la notación del algoritmo de Sugiyama, sea $a_{-1}(x) = 1$, $a_0(x) = 0$ y $a_i(x) = a_{i-2}(x) - h_i(x) a_{i-1}(x)$ para $i \geq 1$. Las siguientes afirmaciones son ciertas.

    \begin{itemize}
        \item $a_i(x) f(x) + b_i(x) s(x) = r_i (x)$ para $i \geq -1$.
        \item $b_i(x) r_{i-1}(x) - b_{i-1} r_i(x) = (-1)^i f(x)$ para $i \geq 0$.
        \item $a_i(x) b_{i-1}(x) - a_{i-1} b_i (x) = (-1)^{i+1}$ para $i \geq 0$.
        \item $gr(b_i(x)) + gr(r_{i-1}(x)) = gr(f(x))$ para $i \geq 0$.
    \end{itemize}
\end{lemma}

\begin{proof}
    Ver Lema 5.4.11 en la página 191, \cite{Huffman_Pless_2010}.
\end{proof}

Comprobemos ahora que el algoritmo de Sugiyama funciona. Por el Lema \ref{lm:dem_sugiyama} (i) tenemos que

\begin{equation}
    \label{dem:sugiyama_relacion}
    a_I(x) x^{2t} + b_I(x) S(x) = r_I(x).
\end{equation}

Además, por la ecuación clave sabemos que

\begin{equation}
    \label{dem:sugiyama_key_equation}
    a(x) x^{2t} + \sigma(x) S(x) = \omega(x)
\end{equation}

para algún polinomio $a(x)$. Multiplicando \ref{dem:sugiyama_relacion} por $\sigma(x)$ y \ref{dem:sugiyama_key_equation} por $b_I(x)$ obtenemos 

\begin{equation}
    \label{dem:sugiyama_relacion_sigma}
    a_I(x) \sigma(x) x^{2t}  + b_I(x) \sigma(x) S(x) = r_I(x) \sigma(x) \quad \text{ y }
\end{equation}
\begin{equation}
    \label{dem:sugiyama_key_equation_b_I}
    a(x) b_I(x) x^{2t} + \sigma(x) b_I(x) S(x) = \omega(x) b_I(x).
\end{equation}

Aplicando módulo $x^{2t}$ a ambas ecuaciones tenemos que 

\begin{align*}
    b_I(x) \sigma(x) S(x) &\equiv r_I(x) \sigma(x) \pmod{x^{2t}} \quad \text{ y }\\
    \sigma(x) b_I(x) S(x) &\equiv \omega(x) b_I(x) \pmod{x^{2t}}.
\end{align*}

Por lo tanto,

\begin{equation}
    \label{dem:sugiyama_modulo}
    r_I(x) \sigma(x) \equiv \omega(x) b_I(x) \pmod{x^{2t}}.
\end{equation}

Como $gr(\sigma(x)) \leq t$, por la elección de $I$,

$$gr(r_I(x) \sigma(x)) = gr(r_I(x)) + gr(\sigma(x)) < t + t = 2t.$$ 

Por el Lema \ref{lm:dem_sugiyama} (iv), la elección de $I$ y como $gr(\omega(x)) < t$, entonces se cumple que 

$$gr(\omega(x) b_I(x)) = gr(\omega(x)) + gr(b_I(x)) < t + gr(b_I(x)) = t + (gr(x^{2t}) - gr(r_{I-1}(x))) \leq 3t - t = 2t.$$

Por \ref{dem:sugiyama_modulo} tenemos que $r_I(x) \sigma(x) = \omega(x) b_I(x)$. Esto, junto con \ref{dem:sugiyama_relacion_sigma} y \ref{dem:sugiyama_key_equation_b_I}, implica que 

\begin{equation}
    \label{dem:sugiyama_implicacion_ecuaciones}
    r_I(x) \sigma(x) \equiv \omega(x) b_I(x) \pmod{x^{2t}}.
\end{equation}

Sin embargo, el Lema \ref{lm:dem_sugiyama} (iii) afirma que $a_I(x)$ y $b_I(x)$ son primos relativos, y por \ref{dem:sugiyama_implicacion_ecuaciones} se cumple que $a(x) = \lambda(x) a_I(x)$. Sustituyendo esta relación en \ref{dem:sugiyama_implicacion_ecuaciones},

\begin{equation}
    \label{dem:sugiyama_sustitucion}
    \sigma(x) = \lambda(x) b_I(x).
\end{equation}

Ahora, sustituyendo estas dos últimas relaciones en \ref{dem:sugiyama_key_equation} obtenemos

$$\lambda(x) a_I(x) x^{2t} + \lambda(x) b_I(x) S(x) = \omega(x).$$ 

La ecuación \ref{dem:sugiyama_relacion} implica que

\begin{equation}
    \label{dem:sugiyama_relacion_omega}
    \omega(x) = \lambda(x) a_I(x) x^{2t} + \lambda(x) b_I(x) S(x) = \lambda(x) \cdot \left( a_I(x) x^{2t} + b_I(x) S(x) \right) = \lambda(x) r_I(x).
\end{equation}

Teniendo en cuenta que los polinomios $\sigma(x)$ y $\omega(x)$ son primos relativos y por \ref{dem:sugiyama_sustitucion} y \ref{dem:sugiyama_relacion_omega}, $\lambda(x)$ tiene que ser una constante no nula, verificando el paso III del algoritmo de Sugiyama.

Como solo estamos interesados en las raíces de $\sigma(x)$, es suficiente con determinar las raíces de $b_I(x)$ obtenidos en el paso II; lo que nos dará los $X_j$. 

Más adelante veremos que este algoritmo sigue funcionando con otras elecciones de $f(x)$ y $s(x)$, con las modificaciones apropiadas de las condiciones sobre las que el algoritmo termina en el paso II. Una de estas modificaciones nos será útil para decodificar los códigos Goppa que veremos a continuación.

\end{comment}